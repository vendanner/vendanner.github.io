---
layout:     post
title:      Hadoop 集群脚本
subtitle:   shell
date:       2019-08-22
author:     danner
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 大数据
    - Hadoop
    - shell
    - 监控
    
---


在编写集群脚本之前，先回顾下 `shell` 知识点

## Shell

### 入门

创建 `wc.sh`，并在文件写入以下内容：

	\#!/bin/bash

	echo "hello shell"

解释下上面两行代码：

- 第一行**注释**表明执行此 `shell` 是 `/bin/bash`；
- 第二行是 `shell` 具体要执行的脚本，输出 `hello shell`。

保存好文件内容后，增加**执行权限** `chmod u+x wc.sh` 后执行 `./wc.sh`,输出如下：

	hello shell

当然你也可以在首行加 `-x` 表示 `debug` 模式，会输出调试信息，整个文件内容:

	#!/bin/bash -x

	echo "hello shell"

执行后输出

	+ echo 'hello shell' 
	hello shell

增加了调试信息 `+ echo 'hello shell' `，代表执行 `echo 'hello shell' ` 语句


### 变量定义与引用

创建 `variable.sh`，输入以下内容：

	#!/bin/bash 
	
	hello='hello'
	date1='date1'
	date2=\`date\` 
	word=word
	
	echo $hello
	echo ${date1}
	echo ${date2}
	echo $word

执行输出：

	hello
	date1
	Thu Aug 22 23:10:34 CST 2019

关于变量，有几个知识点：

- `$` 后跟随的是**变量名**
- \`fun\` 是表示 `fun` 的返回值，例子中就是 `date` 命令返回值
- 字符串可以用 `""`、`''`包裹，也可以不用；但标准用法是用**引号**

当然也有需要**注意点**：

- `=` 前后不能有**空格**
- **变量名**最好用 `{}`，以免引起歧义
- **静态变量**最好用**大写**


### 传递参数

创建 `parameter.sh`，内容如下：
	
	#!/bin/bash

	echo $1
	echo $2
	echo "$#"
	echo "$*"
	echo "PID: $$"

执行 `./parameter.sh a b`，输出：

	a
	b
	2
	a b
	PID: 12545
	
- 执行 `shell` 时，传递 `a`,`b` 两个参数
- `$1` 得到**第一个**参数
- `$2` 得到**第二个**参数
- `$#` 是指**参数的个数**
- `$*` 是指**参数的内容**
- `$$` 是指当前 `shell` 进程的 `PID`


### 数组

创建 `array.sh`，内容如下

	#!/bin/bash

	arr=("john li" wangwu zhangsan)
	echo ${arr[@]}
	echo ${arr[2]}
	echo ${#arr[2]}
	echo ${#arr[@]}

执行 `./array.sh`，输出：
	
	john li wangwu zhangsan
	zhangsan
	8
	3

- 数组用 `()` 表示
- 数组内容用**空格**分割
- `@` 符号取数组所以内容
- `#` 可以类似 `len` 函数，`#变量` 是变量长度，`#arr[@]` 数组 `arr` 的元素个数


### 判断

创建 `if.sh`，内容如下：
	
	#!/bin/bash


	A="abc"
	B="john"
	
	if [ ${A} == ${B} ];then
	        echo "=="
	elif [ ${A} == 'abc' ];then
	        echo "=="
	else
	        echo "!="
	fi

执行 `./if.sh`，输出
	
	==

- `[]` **前后要有空格**
- `==` **前后要有空格**
- `if` 结束符号 `fi`


### 循环

创建 `loop.sh`，内容如下

	#!/bin/bash

	for((i=1;i<5;i++))
	do
	        echo "i = "${i}
	done
	
	
	j=1
	while(($j<5))
	do
	        echo "j = "${j}
	        let "j++"
	done

执行 `./loop.sh`，输出

	i = 1
	i = 2
	i = 3
	i = 4
	j = 1
	j = 2
	j = 3
	j = 4

- **条件**是用 `(())` 包裹
- 循环语句是在 `do ... done` 之内


### 分割

创建 `split.sh`，内容如下：

	#!/bin/bash

	s="rz,j,xx,huhu,yt,co"
	
	OLD_IFS="$IFS"
	IFS=","
	arr=($s)
	IFS="$OLD_IFS"
	
	for x in ${arr[*]}
	do
	        echo $x
	done

执行 `./split.sh`，输出

	rz
	j
	xx
	huhu
	yt
	co


### AWK
	
	[hadoop@node02 learn_shell]$ cat test.log 
	a b c
	1 2 3
	[hadoop@node02 learn_shell]$ cat test.log | awk '{print $1}'
	a
	1
	[hadoop@node02 learn_shell]$ cat test.log | awk '{print $1,$2}'
	a b
	1 2
	[hadoop@node02 learn_shell]$ cat test.log | awk 'NR==1{print}'      
	a b c
	[hadoop@node02 learn_shell]$ cat test.log | awk 'NR==1{print $1}'
	a
	[hadoop@node02 learn_shell]$ cat test.log | awk 'NR>1{print}'     
	1 2 3
	
	[hadoop@node02 learn_shell]$ cat test.log 
	a;b;c
	1;2;3
	[hadoop@node02 learn_shell]$ cat test.log | awk -F ";" '{print $2}'
	b
	2

- `-F` 后面紧跟着的是**分割点**，默认的分割点是**空格**
- `$index` 表示输出 `index` 的内容
- `NR` 表示**行操作**


### sed

`sed` 命令是利用脚本来处理文本文件，主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。

> sed 's/要被取代的字串/新的字串/g'

	[hadoop@node02 learn_shell]$ cat test.log 
	w;w;c
	w;2;3
	[hadoop@node02 learn_shell]$ sed -i 's/w/f/2' test.log 
	[hadoop@node02 learn_shell]$ cat test.log 
	w;f;c
	w;2;3
	[hadoop@node02 learn_shell]$ sed -i 's/w/f/' test.log  
	[hadoop@node02 learn_shell]$ cat test.log 
	f;f;c
	f;2;3
	[hadoop@node02 learn_shell]$ sed -i 's/f/m/g' test.log    
	[hadoop@node02 learn_shell]$ cat test.log 
	m;m;c
	m;2;3

- `-i` 选项可以直接修改文件内容
- `s` 是**替换**，可以搭配正规表示法 
- `g` 代表**每行中第几个**要被替换的字符串，默认是第一个，`g` 代表全部



## 参考资料
[Linux sed 命令](https://www.runoob.com/linux/linux-comm-sed.html)
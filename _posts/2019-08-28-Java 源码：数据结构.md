---
layout:     post
title:      Java 源码：数据结构
subtitle:   
date:       2019-08-28
author:     danner
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
    - 数据结构
---

### List

#### ArrayList

`ArrayList` 字面理解就是由 `array` 组成的 `List`，相当于是个**变长数组**。它底层是个 `Object` 类型的数组，可放置 `null` 。

	// ArrayList 真正存放值的元素
	transient Object[] elementData; 


**构造函数**
	
	// 就是创建 ArrayList，长度为0
	new ArrayList()

`add`

    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
	private void ensureCapacityInternal(int minCapacity) {
	    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
	        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
	    }
	
	    ensureExplicitCapacity(minCapacity);
	}
	
	private void ensureExplicitCapacity(int minCapacity) {
	    modCount++;
	
	    // overflow-conscious code
	    if (minCapacity - elementData.length > 0)
	        grow(minCapacity);
	}
	private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

分位两种情况：当前有值和空值：

- 空值：自动将 `ArrayList` 的 `size` 扩展到 `10`
- 有值：若当前长度还够则不扩容，否则**扩容** `1.5 倍`，最大长度是 `Integer.MAX_VALUE`；**注意不要频繁扩容，因为扩容时涉及数组的复制影响性能；如果预料到要很大空间可以在一开始就开辟大空间**


`remove`

分为两种情况：删 `index` 和 删 `object`

	public E remove(int index) {
		// 保证数组不越界
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }

以上代码可知，删除 `index` 节点后，后面的节点需要往前**拷贝**，这很耗时。

	public boolean remove(Object o) {
        if (o == null) {
			// ArrayList 可存储 null
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }
	private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }

删除 `object` 与 删除 `index`类似，先找到 `object` 的 `index` 然后再往前复制即可。指的注意的是，删除操作后都是往前复制，这在 递增 `for` 循环删除时会出错，最好是**倒序循环**。


**迭代**

`ArrayList` 可被迭代，类中有内部类 `Itr`

	 public Iterator<E> iterator() {
        return new Itr();
    }

    /**
     * An optimized version of AbstractList.Itr
     */
    private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
		final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }


这里需要注意一点：不要在迭代过程中，不能对当前 `List` 有**增删操作**，会导致 `ConcurrentModificationException` 异常；如果你想要在迭代中删除请使用 `Itr` 自带的 `remove()` 函数。这是源于 `next()` 都会去调用 `checkForComodification()` 来检查 `modCount` 和 `expectedModCount` 是否想等，而 `List` 的**增删操作**都会去增加 `modCount` (看上面对应的代码)。

- **优点**：	适合**快速查找**，时间 `O(1)`
- **缺点**： **删除**、指定 `index` **插入**性能很低，涉及数组的后续元素的移动


#### LinkedList



## 参考资料：
[Java编程：删除 List 元素的三种正确方法](https://blog.csdn.net/claram/article/details/53410175)
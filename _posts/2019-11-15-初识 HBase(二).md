---
layout:     post
title:      初识 HBase(二)
subtitle:   
date:       2019-11-15
author:     danner
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - HBase
    - bigdata
---

在[上一节]( https://vendanner.github.io/2019/11/08/初识-HBase/ ) 大致了解 `HBase` 框架，本节补充知识点。

![](https://vendanner.github.io/img/HBase/HBase-arch.png)

- `HLog`：Write Ahead Log，预写日志(节点上所有region 的写操作)
- `memstore`：先写 HLog，再写memStore
  - 超过**阈值**会 flush 成一个 `storeFile`(flush 影响性能)
  - 当 `storeFile`文件数量增加到一定阈值，会触发 **compaction 合并**(会发生GC)
- `storeFile`：小的file **合并**成大文件，文件大小超过阈值又会**分裂**
- `blockCache`：**读缓存**，`RegionServer` 上所有 region 共享；系统启动时完成初始化工作



### 写流程

![](https://vendanner.github.io/img/HBase/write_step.png)

> 写流程不经过 HMaster

- Clinet 向zk `/hbase/meta-region-server`，获取 **hbase:meta 表所在的 RS 节点**
- 向meta RS 获取 `hbase:meta`，并根据 `rowkey` 找到对应的 RS 节点和 Region
- 写请求发送到对应 RS ，依次写入 HLog 以及对应的 memstore
- memstore 超过阈值，会异步 flush 成 storeFile

### 读流程

![](https://vendanner.github.io/img/HBase/read_step.png)

>  写流程不经过 HMaster 

- Clinet 向zk `/hbase/meta-region-server`，获取 hbase:meta 表所在的 RS 节点
- 向meta RS 获取 `hbase:meta`，并根据 `rowkey` 找到对应的 RS 节点和 Region，缓存在本地
- 将读请求发送到对应的RS 节点进行处理
- 先在 `memstore` 读取数据，找不到则去 `blockcache` 读取，再查不到去 `HFile`。

读取的优先级 memstore <--- blockcache <--- HFile，如果到HDFS 上读取显然是慢了，为了提高读取速度，可以**适当加大** blockcache 容量(基于此有些人会认为 HBase 重写轻读，这显然是不合适的)。为了提高读取速度想使用 blockcache ，先确认在表列簇属性 `BLOCKCACHE` 是否开启，默认为 true。

上面的步骤只是读取到对应 `rowkey` 数据，其实在这之后是还有一步需要处理的。当数据有多版本下需要筛选出最新数据；数据有 delete 时需要去除。写数据时只管写，而读数据可能要跨region 获取且结果还要处理，显然对于 HBase 是**重写轻读**。

### 调优

总所周知，memstore 超过阈值会 flush 成 storefile，sorefile 可能会历经合并、分割，region 也可能被分割。这些都是需要参数去设置，也是生产上的**调优点**。

#### `memstore` 

`HBase` 会在如下几种情况下触发 `flush` 操作

- **memstore 级别**： 
  - region 中**任意一个** memstore 大小超过阈值(`hbase.hregion.memstore.flush.size` 默认 `128M`)，就会触发flush；生产上该参数可适当调成倍数。
- **region 级别**：
  - 当region 中所有 memstore 大小之和超过 `hbase.hregion.memstore.flush.size` * `hbase.hregion.memstore.block.multipiler`(默认是2)，触发 flush；生产中 multipiler 可设置为4，列簇一般不超过3，这样 `region` 级别的 flush 就不会触发
- **RegionServer 级别**：这个层次发生 flush 是**灾难性**的，要避免
  - `RegionServer java heap`：RegionServer java 堆大小
  - `hbase.regionserver.global.memstore.size` or `hbase.regionserver.global.memstore.upperLimit`：高水位线，regionserver heap 中供 memstore 占用的总大小，默认 `0.4`
  - `hbase.regionserver.global.memstore.size.lower.limit` or `hbase.regionserver.global.memstore.lowerLimit`：低水位线系数，默认 `0.95`
  - 当 regionserver 的所有的 memstore 的 size 之和，超过低水位线(RS heap * upperlimit * lower)；**RS 强制 flush**，从 memstore 最大的 `region`开始，直到总的 memstore  之和降到水位线之下。
  - 达到低水位线之后如果继续频繁写，会达到高水位线(RS heap * upperlimit)；此时 **RS 阻塞读写**，强制 flush 直至降到低水位线之下。
- **HLog**：
  - ` hbase.regionserver.maxlogs `：HLog 文件大小超过阈值，会触发 `Regions` flush，经验值 `32 * 128M=4G`

- **定期 flush**：
  - ` hbase.regionserver.optionalcacheflushinterval ` ：默认为1小时，如果interval 时间内 Region 都没有flush，则自动去flush(设置为0则关闭，单位是ms)；为防止一次性有过多memstore flush，会有0-5分钟延迟；检测 region 是否有 flush 是 `RegionServer` 中 ` PeriodicMemStoreFlusher `  线程来实施

- 手动：
  - shell 命令执行 `flush 'table name'` or `flush 'region name'`，分别对表或者Region  flush。

#### 合并











## 参考资料

[若泽数据@J哥Blog](https://hackeruncle.github.io/)




---
layout:     post
title:      Redis 初体验
subtitle:  
date:       2019-10-22
author:     danner
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Redis
    - 缓存
---

### 简介

> Redis 是一种基于键值对( key - value) 的 `NoSQL` 数据库，面向`快速执行`场景。

Redis 的数据结构有 `String`、`hash`、`list`、`set`、zset、Bitmaps、HyperLogLog、GEO，常用的是前四种。它最大的特点是快，基于以下几个方面

- 所有数据都是存放在**内存**( 不适合存放大的数据量 )
- **C 语言实现**，执行速度相对会快
- 使用**单线程**，减少线程切换的开销( 最新版本的 redis 有些操作也用多线程)
- 源代码优雅

redis 的数据都放在内存中是不安全的，为了应对异常(断电或者机器故障)，也提供持久化方式：RDB 、AOF。

- `RDB`：当前进程数据生成**快照**保存到硬盘，触发 RDB 持久化过程分为**手动**和**自动**。
- `AOF`：以独立日志的方式**记录每次写命令**，重启时执行AOF 文件来**恢复**数据，解决了数据持久化的实时性是当前主流方式。

值得一提的是，在 `redis 3.0` 版本开始实现了真正的分布式。

### 安装

以下为源码方式安装

```shell
[hadoop@danner000 software]$ wget http://download.redis.io/releases/redis-3.0.7.tar.gz
[hadoop@danner000 software]$ tar -zxvf redis-3.0.7.tar.gz -C ../app/
[hadoop@danner000 software]$ cd ../app/
# 创建软链接
[hadoop@danner000 app]$ ln -s redis-3.0.7/ redis
[hadoop@danner000 redis]$ cd redis
[hadoop@danner000 redis]$ make
# redis 可执行文件移动到 /usr/local/bin 目录 需要 root 权限
[root@danner000 redis]# make install
[hadoop@danner000 src]$ ls -l /usr/local/bin/ | grep redis
-rwxr-xr-x. 1 root root 4589171 Oct 24 11:19 redis-benchmark
-rwxr-xr-x. 1 root root   22225 Oct 24 11:19 redis-check-aof
-rwxr-xr-x. 1 root root   45443 Oct 24 11:19 redis-check-dump
-rwxr-xr-x. 1 root root 4698386 Oct 24 11:19 redis-cli
lrwxrwxrwx. 1 root root      12 Oct 24 11:19 redis-sentinel -> redis-server
-rwxr-xr-x. 1 root root 6471167 Oct 24 11:19 redis-server
# 安装成功可输出版本号
[hadoop@danner000 src]$ redis-cli -v
redis-cli 3.0.7
```

编译安装后会在 redis 的 src 目录多几个可执行文件，简单介绍下

| 可执行文件       | 作用                               |
| ---------------- | ---------------------------------- |
| redis-server     | 启动 redis                         |
| redis-cli        | redis 命令行客户端                 |
| redis-benchmark  | redis 基准测试工具                 |
| redis-check-aof  | redis AOF 持久化文件检测和修复工具 |
| redis-check-dump | redis RDB 持久化文件检测和修复工具 |
| redis-sentinel   | 启动 redis sentinel                |

#### 服务启停

```shell
# 启动服务
[hadoop@danner000 redis]$ redis-server redis.conf 
# 指定配置文件启动，占用控制台窗口
```

```shell
# 修改配置 redis.conf，以守护进程方式启动，日志输出到 redis.log
daemonize yes
logfile "/home/hadoop/app/redis/logs/redis.log"

# 此时启动不占用控制台窗口
[hadoop@danner000 redis]$ redis-server redis.conf 
```

```shell
# 关闭服务
[hadoop@danner000 redis]$ redis-cli shutdown
# 查看日志
86567:M 24 Oct 14:42:45.338 # User requested shutdown...
86567:M 24 Oct 14:42:45.338 * Saving the final RDB snapshot before exiting.
86567:M 24 Oct 14:42:45.352 * DB saved on disk
86567:M 24 Oct 14:42:45.352 * Removing the pid file.
86567:M 24 Oct 14:42:45.352 # Redis is now ready to exit, bye bye...
# 正常关闭会端口客户端连接并生成持久化文件
# 不要用 kill 去杀死redis 服务，这样不会生成持久化文件，还有可能造成资源不释放
```

#### 客户端

客户端有两种方式连接服务：

- 交互式：  redis-cli  -h {host}  -p {port} 

```shell
[hadoop@danner000 redis]$ redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379> keys *
(empty list or set)
```

- 命令式：redis-cli  -h {host}  -p {port}  command

```shell
# 直接获取 hello 键的值
[hadoop@danner000 redis]$ redis-cli -h 127.0.0.1 -p 6379 get hello
"world"
```

#### 全局命令

- 查看所有键 `keys *`

```shell
127.0.0.1:6379> keys *
1) "hello"
2) "myCounter"
```

-  键总数  `dbsize`

```shell
127.0.0.1:6379> dbsize
(integer) 2
```

`dbsize` 是直接获取内置的键数量，复杂度是 `O(1)`；`keys *` 是去遍历所有键，复杂度是 `O(n)`，所以线上环境禁止使用

- 检测key 是否存在 `exists key`

```shell
# key 存在返回 1，不存在返回 0
127.0.0.1:6379> exists hello
(integer) 1
127.0.0.1:6379> exists hell
(integer) 0
```

- 删除 key `del key`

```shell
127.0.0.1:6379> del hello
(integer) 1
127.0.0.1:6379> exists hello
(integer) 0
```

- 对key 设置生命周期  `expire key`

```shell
127.0.0.1:6379> set hello world
OK
# hello key 活 10 s
127.0.0.1:6379> expire hello 10
(integer) 1
# ttl 查看 key 还有多长时间，单位 s
127.0.0.1:6379> ttl hello
(integer) 6
# 返回 -2 表示 key 不存在
127.0.0.1:6379> ttl hello
(integer) -2
# 常用于超大数据集中小数据集的缓存：用到时放到 redis ，过期自动删除
```

- 查看key 数据结构

```shell
127.0.0.1:6379> type myCounter
string
```

### 数据结构

type 命令实际返回的就是当前键的数据结构类型，它们分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合），但这些只是 Redis 对外的数据结构 ，如下所示

![](https://vendanner.github.io/img/redis/type.png)

每种数据结构都有自己底层的内部编码的多种实现，可以在不同的场景选择合适的编码。

![](https://vendanner.github.io/img/redis/object_encoding.png)

```shell
# object encoding 命令可查询内部编码
127.0.0.1:6379> object encoding myCounter
"int"
```

#### 字符串

字符串是 redis 中最基础的数据结构，所有的 key 都是字符串并且其他几种数据结构的都是在字符串的基础上构建的。交互模式下输入 `help @string` 可输出所有相关指令，下面挑三几个常用来演示

- `set`： 给 key 赋值，可以带生命周期
  -  `SET key value [EX seconds] [PX milliseconds] [NX|XX]`
  -  `SETNX key value`，key 不存在才能设置成功
  -  `SETEX key seconds value` ，必须带生命周期(setex = set + ex)
  -  `MSET key value [key value ...]`，批量设置 key 值

```shell
# redis 生命周期 10 s
127.0.0.1:6379> set redis time ex 10
OK
127.0.0.1:6379> ttl redis
(integer) 2
127.0.0.1:6379> set hello world
OK
# 已存在的key 无法用 setnx 赋值
127.0.0.1:6379> setnx hello world1
(integer) 0
127.0.0.1:6379> setnx java ee
(integer) 1
127.0.0.1:6379>
# mset
127.0.0.1:6379> keys *
1) "java"
2) "hello"
3) "myCounter"
127.0.0.1:6379> mset hello1 world1 hello2 world2
OK
127.0.0.1:6379> keys *
1) "java"
2) "hello2"
3) "hello"
4) "hello1"
5) "myCounter"
```

- `get` ：获取 key 值
  - `GET key`
  - `MGET key [key ...]`：批量获取，**生产中建议使用该方法可以减少多次命令带来的网络消耗**

```shell
127.0.0.1:6379> get hello
"world"
127.0.0.1:6379> mget hello hello1 hello2
1) "world"
2) "world1"
3) "world2"
```

- `incr` ：计数
  - `INCR key`：自增1，若 value 不是数字类型则报错
  - `INCRBY key increment`： + increment 
  - `INCRBYFLOAT key increment` ：+ float increment ，
  - `DECR key`：自减1
  - `DECRBY key decrement`：- decrement

```shell
127.0.0.1:6379> incr myCounter
(integer) 2
127.0.0.1:6379> incrby myCounter 10
(integer) 12
127.0.0.1:6379> incrbyfloat myCounter 6.0
"18"
127.0.0.1:6379> decr myCounter
(integer) 17
127.0.0.1:6379> decrby myCounter 3
(integer) 14
```

- 字符串相关操作
  - `STRLEN key`：获取值长度
  - `APPEND key value`：追加字符串
  - `GETRANGE key start end`：substr 
  - `SETRANGE key offset value`：替换某个位置的值

```shell
127.0.0.1:6379> get hello
"world"
127.0.0.1:6379> strlen hello
(integer) 5
127.0.0.1:6379> append hello redis
(integer) 10
127.0.0.1:6379> get hello
"worldredis
# 注意，redis 都是闭包
127.0.0.1:6379> getrange hello 2 6 
"rldre"
127.0.0.1:6379> setrange hello 3 h
(integer) 10
127.0.0.1:6379> get hello
"worhdredis"
```

**内部编码**

- `int`：少于八个字节的数字
- `embstr`：小于39个字节的字符串
- `raw`：大于39个字节的字符串 or 字符串有操作之后

```shell
127.0.0.1:6379> set intkey 123
OK
127.0.0.1:6379> object encoding intkey
"int"
127.0.0.1:6379> object encoding java
"embstr"
127.0.0.1:6379> append java web
(integer) 5
# append 后自动转化为 raw
127.0.0.1:6379> object encoding java
"raw"
```













## 参考资料

Redis 开发与运维


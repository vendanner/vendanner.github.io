---
layout:     post
title:      SQL 训练营
subtitle:   
date:       2019-09-18
author:     danner
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - sql
    - bigdata
    - hive
---

在 `Hive` 上进行 `SQL` 练习。

### `over`

#### 案例一

表中有如下字段：

	domain           time     traffic(T)
	gifshow.com   2019/01/01    5
	yy.com        2019/01/01    4
	huya.com      2019/01/01    1
	gifshow.com   2019/01/20    6
	gifshow.com   2019/02/01    8
	yy.com        2019/01/20    5
	gifshow.com   2019/02/02    7

需求是按月统计每个用户的累计访问量(只能用一个 `SQL`)，结果如下

	domain          month     traffics   totals
	gifshow.com     2019-01      11         11
	gifshow.com     2019-02      15         26
	yy.com          2019-01       9         9
	huya.com        2019-01       1         1

需求分析：

- 每个用户每月的访问量：`group by` 用户，月；然后再 `sum`
- 相同每月数据累加：

第一步的按月和用户统计：

> select domain,substr(time,1,7) ,sum(traffic) from domain_traffic group by domain,substr(time,1,7);

结果输出如下：

	gifshow.com     2019/01 11
	gifshow.com     2019/02 15
	huya.com        2019/01 1
	yy.com  2019/01 9


第二步，相同用户每月累加

	select ms.domain,ms.m,ms.s,sum(ms.s)over(partition by ms.domain order by ms.m) from 
	(select domain,substr(time,1,7) m ,sum(traffic) s from domain_traffic group by domain,substr(time,1,7)) ms;

使用 `sum()over()` 函数实现**累加**功能，`over` 实现**分组排序**，`sum` 实现就有点意思：将**本组内**当前行以及**之前**的行全部相加(01之前没有最终只有01，02之前是01最终是01+02)。


#### 案例二：

表数据如下：
	
	uid		pid
	li  	a
	zhang   b
	li  	a
	zhang   a
	wang    a
	john    a
	zhang   a
	wang    a
	tom 	b
	ao  	b
	wang    b
	tom 	b
	wang    b
	wang    b
	wang    b
	zhang   b
	zhang   b
	ao  	a

1) 统计产品 `UV` <br>
2）统计每个产品 `top3` 用户

`UV`：按产品分组，count (`uid` 排重 )

> select pid,count(distinct uid) from uid_pid group by pid;

结果：

	a       5
	b       4

`top3`：

- 按产品、用户分组，count(1) 排序，limit 取 top (整体取 top)
	
> select uid,pid,count(1) m from uid_pid group by uid,pid order by m desc limit 3

- 产品 `top` ：

	select t.uid,t.pid,t.m from 
	(select s.uid,s.pid,s.m,row_number()over(partition by pid order by s.m desc) as rank from 
	(select uid,pid,count(1) m from uid_pid group by uid,pid) s ) t 
	where t.rank <= 3;

输出

	zhang   a       2
	wang    a       2
	li      a       2
	wang    b       4
	zhang   b       3
	tom     b       2

使用 `row_number()over` 函数实现分组 `Top`。

`row_number()over()` 作用就是**分组排序**并加上**序号**标记：`over` 中按 `pid` 分组，并按 `次数 m` 降序排列，`row_numbe()` 记录排序相当于增加了一列序号 `rank`。 


#### 总结

以上两个案例都用到 `over` 这个函数，我们从 `MR` 角度来讲解 `over` 作用。












## 参考资料

[Hive窗口函数 row_number over()和sum() over()的使用详解](https://blog.csdn.net/weixin_39043567/article/details/90612526)
[hive原理与源码分析-hive源码架构与理论（一）](https://blog.csdn.net/wzq6578702/article/details/71250081)
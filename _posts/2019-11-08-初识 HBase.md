---
layout:     post
title:      初识 HBase
subtitle:   
date:       2019-11-08
author:     danner
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - HBase
    - bigdata
---

### 介绍

- `Google BigTable` 的开源实现
-  分布式 `NoSQL`数据库
-  **列**存储
- 基于 `HDFS`和 `Zookeeper`

![](https://vendanner.github.io/img/HBase/HBase.png)

####  适用场景
**NoSQL = Not Only SQL**

-  适用
    - 存储格式： 半结构化数据， 结构化数据存储， `Key-Value`存储
    - 数据版本： 固定集合（**多版本**） ， 定时删除（`TTL`）
    - 更新： 列族结构经常调整
    - 写`Pattern`： **重写轻读**

-  **不适用** - `SQL` 擅长的 `NoSQL` 都不擅长
    - **事务**
    - **复杂查询** `Operator`：` Join, Union, Group By`
    - 索引支持：
    - 读 `Pattern`: 高并发随机**读**

#### 特点
- 生产环境检验
    -  理论与实践： 理论（`Google BigTable`） 经过生产环境检验
    - 社区： 社区成熟， 丰富工具支持
- 高效
    - 读写 `Pattern`: 将随机读写转化为顺序读写， 适应高并发写入
    - 数据存储格式： **列存储节省空间**
    - 数据倾斜： 数据**均衡**效果好
- 分布式特性
    - `CAP`：一致性， 可用性， 分区容忍性
    - 扩展性： 利用 `HDFS`线性扩展
    - 高可用： 利用 `HDFS`和 `Zookeeper`

### 架构

![](https://vendanner.github.io/img/HBase/HBase-arch.png)

- `Zookeeper`：
  - 主节点选举、节点状态监控
  - 储存**元数据**
- `HMaster`：
  - client 的 `DML` 操作
  - 管理集群的**负载均衡**， 调整 `HRegion` 分布 
- `Region Server`：
  - client 的 `DDL` 操作
  - `HRegion` 管理
  - 汇报节点状态
- `HRegion`：管理表数据，包含 `Store` - 表有几个**列簇**就有几个 `Store`
- `Store`：表数据
  - `MemStore`：一个列簇数据在内存中存储**有且仅有一个**，超过阈值落盘成`StoreFile`
  - `StoreaFile`：一个列簇数据在磁盘中存储，看数据量容量可能会有多个；也叫做 `HFile` 存储在 `HDFS`  上的文件

### 数据模型

`HBase` 中的数据如下展示

![](https://vendanner.github.io/img/HBase/table_data.png)

一条数据的构成

- `RowKey`：每条数据的**主键**，不能重复，设计表结构时需要**重点考虑**，**字典排序**
- `Column Family` ：列簇简称 `CF`，包含一或多列，存储时依据列簇数将表分割成多个 `Store`
- `Column`：列名
- `Version`：时间戳类型为 Long
- `Value`：以 (rowkey + column Family + column) 为key 的值

> 在设计表时，  **CF** 个数最好不超过3个

一条数据的结构清楚了，下面来看看一张表的数据模型

![](https://vendanner.github.io/img/HBase/Table_mode.png)

#### 逻辑视图

![](https://vendanner.github.io/img/HBase/Region_mode.png)

依据 `Region` 划分， `rowkey` 按字典排序划分为不同 Region，相当于是分表。上图row1-row4 划到 region 1；row5-row6 划到region 2；row7-row8 划到 region 3。当某个region 的数据不断增大超过阈值则会被再次分割(HMaster 负责)。

#### 物理视图

![](https://vendanner.github.io/img/HBase/CF_mode.png)

依据列簇(CF) 划分表数据的物理存储，上图左右两侧各表示一个列簇(不同颜色是不同region)，同个region下相同的列簇就会存储在一块( `Store`)。

### 多版本

![](https://vendanner.github.io/img/HBase/mulit_veersion.png)

`HBase` 中有多版本的概念即同 `rowkey`下的某列存在多个多个值，上图中 row1-SkuSum 值。在说明多版本之前先说一个机制：HBase 里的修改并不是直接覆盖，而是**新增一条数据**，只是 `TimeStamp` 不同，此时存在两条数；类似的删除数据也不是立即删除而是对该数据打上 `delete` 标签。由于这个机制的存在，数据自然存在多版本(TimeStamp)。在读取数据时(若没有指定版本)，会读取所有数据然后选取**最新**数据返回。由此可见 ，`HBase` 是**重写轻读**：只管写，但读取时缺要做判断。

> update、delete 的数据在大合并才真正执行，但生产中应避免打合并，GC 有可能会导致HBase 请求卡顿。



### 实战

有理论基础后，我们操作 HBase 来验证下上面的知识。







## 参考资料

[若泽数据@J哥Blog](https://hackeruncle.github.io/)